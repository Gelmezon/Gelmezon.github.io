if("function"!=typeof window.ImportBondageCollege)throw alert("Club not detected! Please only use this while you have Club open!"),"Dependency not met";if(void 0!==window.BCX_Loaded)throw alert("BCX is already detected in current window. To reload, please refresh the window."),"Already loaded";window.BCX_Loaded=!1,console.debug("BCX: Parse start..."),function(){"use strict";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var o,t={};o=t,function(){const e="1.0.2";function t(e){alert("Mod ERROR:\n"+e);const o=new Error(e);throw console.error(o),o}const n=new TextEncoder;function a(e){return!!e&&"object"==typeof e&&!Array.isArray(e)}function r(e){const o=new Set;return e.filter((e=>!o.has(e)&&o.add(e)))}const i=new Map,d=new Set;function c(e){d.has(e)||(d.add(e),console.warn(e))}function s(e,o){if(0===o.size)return e;let t=e.toString().replaceAll("\r\n","\n");for(const[n,a]of o.entries())t.includes(n)||c(`ModSDK: Patching ${e.name}: Patch ${n} not applied`),t=t.replaceAll(n,a);return(0,eval)(`(${t})`)}function l(e){const o=[],t=new Map,n=new Set;for(const a of h.values()){const r=a.patching.get(e.name);if(r){o.push(...r.hooks);for(const[o,i]of r.patches.entries())t.has(o)&&t.get(o)!==i&&c(`ModSDK: Mod '${a.name}' is patching function ${e.name} with same pattern that is already applied by different mod, but with different pattern:\nPattern:\n${o}\nPatch1:\n${t.get(o)||""}\nPatch2:\n${i}`),t.set(o,i),n.add(a.name)}}return o.sort(((e,o)=>o.priority-e.priority)),{hooks:o,patches:t,patchesSources:n,final:s(e.original,t)}}function f(e,o=!1){let t=i.get(e);if(t)o&&(t.precomputed=l(t));else{let o=window;const r=e.split(".");for(let t=0;t<r.length-1;t++)if(o=o[r[t]],!a(o))throw new Error(`ModSDK: Function ${e} to be patched not found; ${r.slice(0,t+1).join(".")} is not object`);const d=o[r[r.length-1]];if("function"!=typeof d)throw new Error(`ModSDK: Function ${e} to be patched not found`);const c=function(e){let o=-1;for(const t of n.encode(e)){let e=255&(o^t);for(let o=0;o<8;o++)e=1&e?-306674912^e>>>1:e>>>1;o=o>>>8^e}return((-1^o)>>>0).toString(16).padStart(8,"0").toUpperCase()}(d.toString().replaceAll("\r\n","\n")),s={name:e,original:d,originalHash:c};t=Object.assign(Object.assign({},s),{precomputed:l(s)}),i.set(e,t),o[r[r.length-1]]=function(e){return function(...o){const t=e.precomputed,n=t.hooks,a=t.final;let r=0;const i=d=>{var c,s,l,f;if(r<n.length){const o=n[r];r++;const t=null===(s=(c=y.errorReporterHooks).hookEnter)||void 0===s?void 0:s.call(c,e.name,o.mod),a=o.hook(d,i);return null==t||t(),a}{const n=null===(f=(l=y.errorReporterHooks).hookChainExit)||void 0===f?void 0:f.call(l,e.name,t.patchesSources),r=a.apply(this,o);return null==n||n(),r}};return i(o)}}(t)}return t}function p(){const e=new Set;for(const o of h.values())for(const t of o.patching.keys())e.add(t);for(const o of i.keys())e.add(o);for(const o of e)f(o,!0)}function u(){const e=new Map;for(const[o,t]of i)e.set(o,{name:o,originalHash:t.originalHash,hookedByMods:r(t.precomputed.hooks.map((e=>e.mod))),patchedByMods:Array.from(t.precomputed.patchesSources)});return e}const h=new Map;function g(e){h.get(e.name)!==e&&t(`Failed to unload mod '${e.name}': Not registered`),h.delete(e.name),e.loaded=!1}function w(e,o,n){"string"==typeof e&&e||t("Failed to register mod: Expected non-empty name string, got "+typeof e),"string"!=typeof o&&t(`Failed to register mod '${e}': Expected version string, got ${typeof o}`),n=!0===n;const r=h.get(e);r&&(r.allowReplace&&n||t(`Refusing to load mod '${e}': it is already loaded and doesn't allow being replaced.\nWas the mod loaded multiple times?`),g(r));const i=o=>{"string"==typeof o&&o||t(`Mod '${e}' failed to patch a function: Expected function name string, got ${typeof o}`);let n=c.patching.get(o);return n||(n={hooks:[],patches:new Map},c.patching.set(o,n)),n},d={unload:()=>g(c),hookFunction:(o,n,a)=>{c.loaded||t(`Mod '${c.name}' attempted to call SDK function after being unloaded`);const r=i(o);"number"!=typeof n&&t(`Mod '${e}' failed to hook function '${o}': Expected priority number, got ${typeof n}`),"function"!=typeof a&&t(`Mod '${e}' failed to hook function '${o}': Expected hook function, got ${typeof a}`);const d={mod:c.name,priority:n,hook:a};return r.hooks.push(d),p(),()=>{const e=r.hooks.indexOf(d);e>=0&&(r.hooks.splice(e,1),p())}},patchFunction:(o,n)=>{c.loaded||t(`Mod '${c.name}' attempted to call SDK function after being unloaded`);const r=i(o);a(n)||t(`Mod '${e}' failed to patch function '${o}': Expected patches object, got ${typeof n}`);for(const[a,i]of Object.entries(n))"string"==typeof i?r.patches.set(a,i):null===i?r.patches.delete(a):t(`Mod '${e}' failed to patch function '${o}': Invalid format of patch '${a}'`);p()},removePatches:e=>{c.loaded||t(`Mod '${c.name}' attempted to call SDK function after being unloaded`),i(e).patches.clear(),p()},callOriginal:(o,n,a)=>(c.loaded||t(`Mod '${c.name}' attempted to call SDK function after being unloaded`),"string"==typeof o&&o||t(`Mod '${e}' failed to call a function: Expected function name string, got ${typeof o}`),Array.isArray(n)||t(`Mod '${e}' failed to call a function: Expected args array, got ${typeof n}`),function(e,o,t=window){return f(e).original.apply(t,o)}(o,n,a)),getOriginalHash:o=>("string"==typeof o&&o||t(`Mod '${e}' failed to get hash: Expected function name string, got ${typeof o}`),f(o).originalHash)},c={name:e,version:o,allowReplace:n,api:d,loaded:!0,patching:new Map};return h.set(e,c),Object.freeze(d)}function m(){const e=[];for(const o of h.values())e.push({name:o.name,version:o.version});return e}let y;const M=void 0===window.bcModSdk?window.bcModSdk=function(){const o={version:e,apiVersion:1,registerMod:w,getModsInfo:m,getPatchingInfo:u,errorReporterHooks:Object.seal({hookEnter:null,hookChainExit:null})};return y=o,Object.freeze(o)}():(a(window.bcModSdk)||t("Failed to init Mod SDK: Name already in use"),1!==window.bcModSdk.apiVersion&&t(`Failed to init Mod SDK: Different version already loaded ('1.0.2' vs '${window.bcModSdk.version}')`),window.bcModSdk.version!==e&&alert(`Mod SDK warning: Loading different but compatible versions ('1.0.2' vs '${window.bcModSdk.version}')\nOne of mods you are using is using an old version of SDK. It will work for now but please inform author to update`),window.bcModSdk);Object.defineProperty(o,"__esModule",{value:!0}),o.default=M}();e(t).registerMod("MyExampleModName","1.0.0").hookFunction("SpeechGarble",4,((e,o)=>{const t=e[1];return o(e)+"<>"+t}))}();
//# sourceMappingURL=candy-bot.js.map
